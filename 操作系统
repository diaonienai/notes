1.用户态，内核态
内核态：处理器执行内核代码
用户态：处理器执行用户代码
例子：用户运行一个程序，进程运行在用户态，如果要执行文件操作，比如read，write等系统调用，此时cpu切换到最高级别的运行模式，执行内核中代码，内核态，完成操作后切换回最低级别的模式，回到用户态，运行用户代码

2.内核线程，用户线程
内核线程：
（1）内核线程的调度由内核负责，一个内核线程处于阻塞状态时不影响其他的内核线程
（2）这些线程可以在全系统内进行资源的竞争
（3）内核线程切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态，即存在用户态和内核态之间的转换
用户线程：
（1）用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程（用户进程）本身，内核并不能看到用户线程，内核并不知道用户线程的存在
（2）不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程
（3）内核资源的分配仍然是按照进程（用户进程）进行分配的；各个用户线程只能在进程内进行资源竞争
（4）每个用户线程并不具有自身的线程上下文。因此，就线程的同时执行而言，任意给定时刻每个进程只能够有一个线程在运行，而且只有一个处理器内核会被分配给该进程
联系：
一对一模型：
有了内核线程，每个用户线程被映射或绑定到一个内核线程，java就是这个
多对一模型：
多个用户线程映射到一个内核线程，如果其中一个线程阻塞，那么所有线程将无法执行




